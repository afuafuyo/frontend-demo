## 上节回顾

#### 1 UML

###### 1.1 依赖关系

依赖关系是一种使用关系，它是对象之间耦合度最弱的一种关系

###### 1.2 关联关系

关联关系是一种引用关系，表示一类对象与另一类对象之间的关系，包含：聚合关系、组合关系

###### 1.3 泛化和实现关系



#### 2 设计模式原则

###### 2.1 单一职责原则

一个类应该只有一个发生变化的原因（一个类只实现一个功能）

###### 2.2 接口隔离原则

客户端不应该被迫依赖于它所不需要的方法（面向接口编程）

###### 2.3 依赖倒转原则

高层模块不应该依赖低层模块，两者都应该依赖其抽（面向抽象编程）

手机抽象出App层的例子

###### 2.4 里氏替换原则

讨论了关于继承的问题，子类尽量不要重写父类的方法，在适当情况下可以使用 `关联或者依赖` 来解决问题

###### 2.5 开闭原则

对扩展开放，对修改关闭（软件在需求变化时，可以通过扩展软件实体来实现需求，而不是修改使用方代码）

###### 2.6 迪米特原则

两个软件实体无需直接通信，那么就不应该发生直接的相互调用，可以通过第三方转发该调用

比如鱼吧想发一条站内信，鱼吧应该使用站内信提供的SDK，而不是鱼吧直接调用站内信服务

###### 2.7 合成复用原则

和里氏替换原则类似









## 单例模式

【定义】一个类只有一个实例，且该类能够自行创建类的实例的一种模式

【特点】

1. 只有一个实例
2. 单例对象由自身创建

【优点】

1. 减少内存开销
2. 资源共享

【例】实际工作中打印日志的类或者事件监听类不需要有多个实例，就可以使用单例模式

```typescript
class Event {
    private static instance: Event = null;
    
    private constructor() {}
    
    public static getInstance() {
        if(null === Event.instance) {
            Event.instance = new Event();
        }
        
        return Event.instance;
    }
}
```



## 工厂模式

任何可以产生对象的方法和类，都可以称之为工厂，单例也可以看成工厂（静态工厂）

工厂分类：

1. 简单工厂

2. 抽象工厂（包含四个要素）

    2.1 抽象工厂

    2.2 具体工厂

    2.3 抽象产品

    2.4 具体产品

抽象工厂是对简单工厂的进一步抽象而来的

既然可以使用 `new` 创建对象，为什么还有工厂？

工厂可以灵活地控制生产过程，比如可以控制对象创建的权限，添加日志控制等

【例】现实中存在各种交通工具供我们使用

1. 可以任意使用交通工具
2. 可以校验交通工具使用权
3. 灵活定制产品族



首先，实现任意使用交通工具

```typescript
class Main {
    constructor() {
        // 开汽车
        const car: Car = new Car();
        car.run();
        
        // 开火车
        const train: Train = new Train();
        train.go();
        
        // 开飞机
        const plain: Plain = new Plain();
        plain.fly();
    }
}
```

由于交通工具众多，每次变更交通工具都需要重新编写代码。首先能想到的就是进行封装

```typescript
interface Moveable {
    move(): void;
}
class Car implements Moveable {
    move() {
        console.log('car running ...');
    }
}

class Main {
    constructor() {
        const moveable: Movealbe = new Car();
        moveable.move();
    }
}
```



其次，实现对交通工具添加一些权限控制，比如开飞机必须要求有执照

```typescript
// 将权限直接写到业务代码中
class Main {
    constructor() {
        const moveable: Movealbe = new Plain();
        // 权限控制
        if(xxx) {
            moveable.move();
        }
    }
}
```

使用简单工厂重新组织交通工具，将校验逻辑移动到工厂中

```typescript
// 将权限移动到工厂中
class SimpleFactory {
	createCar(): Moveable {
        return new Car();
    }
    
    createPlain(): Moveable {
        // todo 添加权限控制
        if(xxx) {}
        return new Plain();
    }
}

class Main {
    constructor() {
        const f = new SimpleFactory();
        const moveable = f.createPlain();
        moveable.move();
    }
}
```



最后，实现对产品族的扩展，如果扔使用简单工厂，那么工厂会越来越臃肿，可以使用抽象工厂重构

```typescript
// 抽象产品
interface class Moveable {
    abstract move(): void;
}

// 具体产品
class CommonCar implements Moveable {}
class CyberpunkCar implements Moveable {}
class CommonPlain implements Moveable {}
class CyberpunkPlain implements Moveable {}

// 抽象工厂
abstract class Factory {
    abstract createCar(): Moveable;
    abstract createPlain(): Moveable;
}

// 具体工厂
class CommonFactory extends Factory {
    createCar(): Moveable {
        return new CommonCar();
    }
    createPlain(): Moveable {
        return new CommonPlain();
    }
}
class CyberpunkFactory extends Factory {
    createCar(): Moveable {
        return new CyberpunkCar();
    }
    createPlain(): Moveable {
        return new CyberpunkPlain();
    }
}
```

```typescript
class Main {
    constructor() {
        // 如果需要变更产品族 只改这里就行
        const f = new CommonFactory/* CyberpunkFactory */();
        
        const car = f.createCar();
        car.move();
        
        const plain = f.createPlain();
        plain.move();
    }
}
```

【思考】interface 和 abstract ； 日常使用场景