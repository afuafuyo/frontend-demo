## 设计模式的重要性

软件工程中，设计模式是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案。这个术语是由埃里希-伽马（ Erich Gamma ）等人在 20 世纪 90 年代从建筑设计领域引入到计算机科学的。

设计模式是用来解决特定问题的一系列套路，可以用来提高代码的复用性、扩展性和可靠性。

想象一下：

* 一个项目开发完成，客户提出了新功能（扩展性）
* 一个项目开发完成，原开发人员离职，怎么接手维护这个项目（可维护性、规范性）

哪里会用到设计模式

* 功能模块编写（算法数据结构 + 设计模式）
* 框架（设计模式）



## 设计模式七大原则

#### 设计模式目的

在实际工作中，程序员面临着来自耦合性、内聚性、可扩展性、重用性、灵活性等多方面的挑战。设计模式就是为了解决这些问题。

1. 复用性提高

    相同功能的代码不需要编写多次

2. 规范性提高

    规范的代码可读性更高，便于其他人阅读和理解

3. 可扩展性提高

    当需要增加新功能时非常方便，具有较高的可维护性

4. 可靠性提高

    新功能的变更不会导致旧功能出现异常

5. 程序对外呈现高内聚、低耦合

#### 设计模式为什么那样设计

设计模式也是有其设计依据的，主要有七大原则

1. 单一职责原则
2. 接口隔离原则
3. 依赖倒转原则
4. 里氏替换原则
5. 开闭原则
6. 迪米特原则
7. 合成复用原则

#### 1. 单一职责原则

【定义】职责指类发生变化的原因，单一职责原则规定一个类应该只有一个发生变化的原因。

如果一个类 A 负责两个职责：职责 1 和职责 2 ，那么当职责 1 需求变更而需要改变 A 类时，就可能造成对职责 2 的影响。单一职责原则中应该将不同职责分到不同的类实现。

【例】实现一个提示弹框

```react
class Dialog extends React.Component {
    show(msg: string) {
        return (
            <div>
                <div>{msg}</div>
                <footer>
                    <button>确定</button>
                </footer>
            </div>
        );
    }
}

// 两种使用场景
class Page extends React.Component {
    // 想提示一条信息
    ReactDom.render(<Dialog msg="提交成功" />, document.body);

    // 想给用户选择 需要对类进行修改 修改可能会对原有功能形成影响
    ReactDom.render(<Dialog msg="您确定删除该条数据吗？" />, document.body);
}
```

比如以兼容方式，将代码修改成了下面的方式，虽然满足了需求，但是对原有功能产生了潜在影响（需要看使用原功能的地方是否扔正常）

```react
// 另一种违反单一职责原则的情况
class Dialog extends React.Component {
    // 修改了业务逻辑
    show(msg: string) {
        const showCancel = this.props.showCancel;

        return (
            <div>
                <div>{msg}</div>
                <footer>
                    {showCancel ? <button>取消</button> : null}
                    <button>确定</button>
                </footer>
            </div>
        );
    }
}

// 使用
class Page extends React.Component {
    // 想提示一条信息
    ReactDom.render(<Dialog msg="您确定删除该条数据吗" showCancel={true} />, document.body);
}
```



根据单一职责原则进行代码修改

```react
// 采用类级别的分离
class Alert extends React.Component {
    show(msg: string) {
        return (
            <div>
                <div>{msg}</div>
                <footer>
                    <button>确定</button>
                </footer>
            </div>
        );
    }
}

class Confirm extends React.Component {
    show(msg: string) {
        return (
            <div>
                <div>{msg}</div>
                <footer>
                    <button>取消</button>
                    <button>确定</button>
                </footer>
            </div>
        );
    }
}

// 使用
class Page extends React.Component {
    // 想提示一条信息
    ReactDom.render(<Alert msg="提交成功" />, document.body);

    // 想给用户选择
    ReactDom.render(<Confirm msg="您确定删除该条数据吗？" />, document.body);
}
```

以上方案遵循了单一职责原则，但是在业务相对简单时，显得相对麻烦，可以将职责在方法级别进行拆分

```react
// 方法级别的单一职责原则
class Dialog extends React.Component {
    confirm(msg: string) {
        return (
            <div>
                <div>{msg}</div>
                <footer>
                    <button>取消</button>
                    <button>确定</button>
                </footer>
            </div>
        );
    }

    alert(msg: string) {
        return (
            <div>
                <div>{msg}</div>
                <footer>
                    <button>确定</button>
                </footer>
            </div>
        );
    }
}
```

单一职责优点：

1. 降低类的复杂度，一个类负责一个职责
2. 提高类的规范性和可扩展性
3. 降低需求变更引起的风险

需要注意的事项

通常情况下，应遵循单一职责原则，但在逻辑足够简单，类方法足够少的情况下，可以在方法级别保持单一职责原则



#### 2. 接口隔离原则

【定义】客户端不应该被迫依赖于它所不需要的方法；一个类对另一个类的依赖应该建立在最小的接口上。

【例】实现一个内容处理器

```typescript
interface IContentProcessor {
    /**
     * 解析 html
     */
    parseHtml(content: string): string;

    /**
     * 解析协议
     */
    parseProtocol(content: string): string;
}

// 解析帖子的类
class PostContentProcessor implements IContentProcessor {
    parseHtml(content: string): string {
        // todo 解析 html
    }

    parseProtocol(content: string): string {
        // 不会使用
    }
}

// 解析动态的类
class DynamicProcessor implements IContentProcessor {
    parseHtml(content: string): string {
        // 不会使用
    }

    parseProtocol(content: string): string {
        // todo 解析协议
    }
}
```

以上接口设计导致内容处理类多余的实现了本身并不需要的方法，违反了接口隔离原则，需要优化

```typescript
interface IPostProcessor {
    /**
     * 解析 html
     */
    parseHtml(content: string): string;
}
interface IDynamicProcessor {
    /**
     * 解析协议
     */
    parseProtocol(content: string): string;
}

class PostContentProcessor implements IPostProcessor {
    parseHtml(content: string): string {
        // todo 解析 html
    }
}
class DynamicProcessor implements IDynamicProcessor {
    parseProtocol(content: string): string {
        // todo 解析协议
    }
}
class YbProcessor implements IPostProcessor, IDynamicProcessor {
    parseHtml(content: string): string {
        // todo
    }

    parseProtocol(content: string): string {
        // todo
    }
}
```



#### 3. 依赖倒转原则（从依赖细节到依赖抽象）

【前提】在软件设计中，细节往往具有多变性，而抽象层则相对稳定，因此以抽象为基础搭建起来的架构要比以细节为基础搭建起来的架构要稳定得多。

【定义】高层模块不应该依赖低层模块（被依赖方即服务提供方为低层），两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。依赖倒转的核心思想是要面向抽象或接口编程，而不是面向实现编程。

【例】手机上有很多可以被打开的 App ，设计一个使用手机的场景

```typescript
// 面向实现编程实现手机打开应用
// 高层模块
class Phone {
    // 这里依赖了低层模块
    openTaobao(tb: Taobao): void {
        tb.open();
    }

    // 这里依赖了低层模块
    openQQ(qq: QQ): void {
        qq.open();
    }
}

// 服务提供方
// 低层模块
class Taobao {
    open(): void {}
}
class QQ {
    open(): void {}
}

class Client {
    run() {
        const phone = new Phone();
        phone.openTaobao(new Taobao());
        phone.openQQ(new QQ());
    }
}
```

以上设计表示为

![](./dp/dip.png)



按照依赖倒转原则优化代码

将低层模块 `Taobao QQ` 进行依赖抽象处理，将高层模块 `Phone` 也进行依赖抽象处理，

![](./dp/dip-youhua.png)

```typescript
interface App {
    open(): void;
}
// 低层模块进行依赖抽象处理 抽离出所有应用的共性 open 方法
class QQ implements App {
    open(): void {}
}
class Taobao implements App {
    open(): void {}
}

// 高层模块
class Phone() {
    // 此时是以来抽象 而不是依赖低层细节
    openApp(app: App) {
        app.open();
    }
}

class Client {
    run() {
        const phone = new Phone();
        phone.openApp(new QQ());
        phone.openApp(new Taobao());
    }
}
```



#### 4. 里氏替换原则

【定义】继承必须确保超类所拥有的的特性在子类中依然成立

里氏替换原则主要阐述了关于继承的一些原则，即什么时候应该使用继承，什么时候不应该使用，以及其中蕴含的道理。

1. 父类已经实现的方法，相当于一些规范和契约，虽然子类可以不遵守这些契约（如将某方法进行重写），但子类对这些已实现的方法进行任意修改，会对继承体系造成破坏
2. 继承在给程序设计带来便利的同时，也带来了弊端，继承会给程序带来侵入性，要知道继承是一种 `高耦合` 操作。如果一个类 A 被其他类继承，那么后期对 A 类的修改，就需要考虑到所有的子类，子类可能会发生故障（耦合性故障）

如何正确使用继承？就是用到了里氏替换原则

里氏替换原则告诉我们，在子类中 `尽量不要重写父类的方法` ，在适当情况下可以使用 `聚合、组合(也就是关联关系)或者依赖` 来解决问题

```typescript
// 父类
class A {
    // 本来有个求和函数
    fun(a: number, b: number): number {
        return a + b;
    }
}

class B extends A {
    // 无意中改为了求差
    fun(a: number, b: number): number {
        return a - b;
    }

    // 想求和 但是忘记重写了求和方法
    fun2(a: number, b: number， c: number): number {
        return this.fun(a, b) + c;
    }
}
```



使用关联关系修改代码

```typescript
class B {
    constructor() {
        // 将 A 类与 B 类进行关联 形成聚合
        this.a = new A();
    }

    sub(a: number, b: number): number {
        return a - b;
    }

    // 采用关联方式调用父类方法
    plus(a: number, b: number, c: number): number {
        return this.a.fun(a, b) + c;
    }
}
```



#### 5. 合成复用原则（同里氏替换原则异曲同工）

【定义】合成复用原则又叫组合/聚合复用原则，它要求在软件复用时，尽量先使用 `组合或者聚合（关联关系）` 等方式实现，其次才考虑使用继承，使用继承时还需考虑里氏替换原则

【例如】左图使用继承方式调用父类方法获取用户信息，右图采用聚合关系调用类的方法获取用户信息

![](./dp/dip-fuyong.png)



#### 6. 迪米特原则

【定义】迪米特原则又叫最少知识原则，定义是：只与你的直接朋友交谈。不要跟“陌生人”说话。

其含义是，如果两个软件实体无需直接通信，那么就不应该发生直接的相互调用，可以通过第三方转发该调用，其目的是降低类之间的耦合度，提高模块间的独立性。

【朋友定义】：当前对象的成员变量、当前对象创建的对象、当前对象的方法参数

【陌生人】：以局部变量方式出现的依赖对象

【例】某人想开发一款软件，需要找软件外包公司，而不是直接找软件开发人员



#### 7. 开闭原则

【定义】软件实体应当对扩展开放（服务提供方），对修改关闭（服务使用方）。开闭原则是编程中 `最基础最重要` 的原则。

要求设计的软件，在需求变化时，可以通过扩展软件实体的行为来实现需求，而不是修改使用方代码

编程中遵循的其他原则，以及使用设计模式的目的核心是开闭原则

【例】实现一个画图类

```typescript
// 设计一个画图工具 实现了画矩形和圆形
// 使用方
class DrawEditor {
    rectangle: Rectangle;
    circle: Circle;

    // 使用矩形作画
    drawRectangle(): void {
        this.rectangle.draw();
    }

    // 使用圆形作画
    drawCircle(): void {
        this.circle.draw();
    }
    
    // 如果需要扩展其他图形 需要修改使用方代码
    drawXxx(): void {
        // todo
    }
}

// 画图提供方
class Rectangle {
    draw(): string {
        return '画出一个矩形';
    }
}
class Circle {
    draw(): string {
        return '画出一个圆';
    }
}
```

以上代码，如果需要扩展画图工具的功能，比如增加画三角形，就需要修改使用方代码，不符合开闭原则

按照开闭原则修改代码如下

```typescript
abstract class Shape {
    abstract draw(): string;
}

// 使用方
class DrawEditor {
    drawShape(shape: Shape): void {
        shape.draw();
    }
}

// 提供方
class Rectangle extends Shape {
    draw(): string {
        return '画出一个矩形';
    }
}
class Circle extends Shape {
    draw(): string {
        return '画出一个圆';
    }
}
class Triangle extends Shape {
    draw(): string {
        return '画出一个三角';
    }
}
```




