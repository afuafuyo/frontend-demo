## 设计模式的重要性

软件工程中，设计模式是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案。这个术语是由埃里希-伽马（ Erich Gamma ）等人在 20 世纪 90 年代从建筑设计领域引入到计算机科学的。

设计模式是用来解决特定问题的一系列套路，可以用来提高代码的复用性、扩展性和可靠性。

想象一下：

* 一个项目开发完成，客户提出了新功能（扩展性）
* 一个项目开发完成，原开发人员离职，怎么接手维护这个项目（可维护性、规范性）

哪里会用到设计模式

* 功能模块编写（算法数据结构 + 设计模式）
* 框架（设计模式）



## 设计模式七大原则

#### 设计模式目的

在实际工作中，程序员面临着来自耦合性、内聚性、可扩展性、重用性、灵活性等多方面的挑战。设计模式就是为了解决这些问题。

1. 复用性提高

    相同功能的代码不需要编写多次

2. 规范性提高

    规范的代码可读性更高，便于其他人阅读和理解

3. 可扩展性提高

    当需要增加新功能时非常方便，具有较高的可维护性

4. 可靠性提高

    新功能的变更不会导致旧功能出现异常

5. 程序对外呈现高内聚、低耦合

#### 设计模式为什么那样设计

设计模式也是有其设计依据的，主要有七大原则

1. 单一职责原则
2. 接口隔离原则
3. 依赖倒转原则
4. 里氏替换原则
5. 开闭原则
6. 迪米特原则
7. 合成复用原则

#### 1. 单一职责原则

【定义】单一职责原则又称单一功能原则，由 Robert C. Martin 于《敏捷软件开发：原则、模式和实践》一书中提出。职责指类发生变化的原因，单一职责原则规定一个类应该只有一个发生变化的原因。

如果一个类有多个被改变的原因，那这个类就具有多个职责。

如果一个类 A 负责两个职责：职责 1 和职责 2 ，那么当职责 1 需求变更而需要改变 A 类时，就可能造成对职责 2 的影响。单一职责原则中应该将不同职责分到不同的类实现。

【例】实现一个提示弹框

```react
class Dialog extends React.Component {
	show(msg: string) {
        return (
        	<div>
                <div>{msg}</div>
				<footer>
                    <button>确定</button>
                </footer>
            </div>
        );
    }
}

// 使用
class Page extends React.Component {
    // 想提示一条信息
    ReactDom.render(<Dialog msg="提交成功" />, document.body);

	// 想给用户选择
	ReactDom.render(<Dialog msg="您确定删除该条数据吗？" />, document.body);
}
```

以上 `Dialog` 类在此时场景下违反了单一职责原则，还有一种常见的违反单一职责原则的情况

```react
// 另一种违反单一职责原则的情况
class Dialog extends React.Component {
    // 修改了业务逻辑
	show(msg: string) {
        const showCancel = this.props.showCancel;

        return (
        	<div>
                <div>{msg}</div>
				<footer>
                    {showCancel ? <button>取消</button> : null}
                    <button>确定</button>
                </footer>
            </div>
        );
    }
}

// 使用
class Page extends React.Component {
    // 想提示一条信息
    ReactDom.render(<Dialog msg="您确定删除该条数据吗" showCancel={true} />, document.body);
}
```



根据单一职责原则进行代码修改

```react
// 采用类级别的分离
class Alert extends React.Component {
	show(msg: string) {
        return (
        	<div>
                <div>{msg}</div>
				<footer>
                    <button>确定</button>
                </footer>
            </div>
        );
    }
}

class Confirm extends React.Component {
	show(msg: string) {
        return (
        	<div>
                <div>{msg}</div>
				<footer>
                    <button>取消</button>
                    <button>确定</button>
                </footer>
            </div>
        );
    }
}

// 使用
class Page extends React.Component {
    // 想提示一条信息
    ReactDom.render(<Alert msg="提交成功" />, document.body);

	// 想给用户选择
	ReactDom.render(<Confirm msg="您确定删除该条数据吗？" />, document.body);
}
```

以上方案遵循了单一职责原则，但是改动比较大，我们还有优化的空间

```react
// 方法级别的单一职责原则
class Dialog extends React.Component {
	confirm(msg: string) {
        return (
        	<div>
                <div>{msg}</div>
				<footer>
                    <button>取消</button>
                    <button>确定</button>
                </footer>
            </div>
        );
    }

    alert(msg: string) {
        return (
        	<div>
                <div>{msg}</div>
				<footer>
                    <button>确定</button>
                </footer>
            </div>
        );
    }
}
```

综上，单一职责原则就是要做到各司其职，需要注意的事项和细节

1. 降低类的复杂度，一个类负责一个职责
2. 提高类的规范性和可扩展性
3. 降低需求变更引起的风险
4. 通常情况下，应遵循单一职责原则，只有在逻辑足够简单，类方法足够少的情况下，可以在方法级别保持单一职责原则



#### 2. 接口隔离原则

【定义】客户端不应该被迫依赖于它所不需要的方法；一个类对另一个类的依赖应该建立在最小的接口上。

单一职责原则和接口隔离原则都是为了提高类的内聚性，降低类之间的耦合性。

【例】实现一个内容处理器

```typescript
interface IContentProcessor {
    /**
     * 解析 html
     */
    parseHtml(content: string): string;

    /**
     * 解析协议
     */
    parseProtocol(content: string): string;
}

// 解析帖子的类
class PostContentProcessor implements IContentProcessor {
    parseHtml(content: string): string {
        // todo 解析 html
    }

    parseProtocol(content: string): string {
        // 不会使用
    }
}

// 解析动态的类
class DynamicProcessor implements IContentProcessor {
    parseHtml(content: string): string {
        // 不会使用
    }

    parseProtocol(content: string): string {
        // todo 解析协议
    }
}
```

以上接口设计导致内容处理类多余的实现了本身并不需要的方法，违反了接口隔离原则，需要优化

```typescript
interface IPostProcessor {
    /**
     * 解析 html
     */
    parseHtml(content: string): string;
}
interface IDynamicProcessor {
    /**
     * 解析协议
     */
    parseProtocol(content: string): string;
}

class PostContentProcessor implements IPostProcessor {
    parseHtml(content: string): string {
        // todo 解析 html
    }
}
class DynamicProcessor implements IDynamicProcessor {
    parseProtocol(content: string): string {
        // todo 解析协议
    }
}
class YbProcessor implements IPostProcessor, IDynamicProcessor {
    parseHtml(content: string): string {
        // todo
    }

    parseProtocol(content: string): string {
        // todo
    }
}
```



#### 3. 依赖倒转原则

【定义】高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。

依赖倒转的核心思想是要面向接口编程，而不是面向实现编程。

在软件设计中，细节往往具有多变性，而抽象层则相对稳定，因此以抽象为基础搭建起来的架构要比以细节为基础搭建起来的架构要稳定得多。

使用接口或者抽象类的目的是为了制定规范，它不涉及任何具体操作，而是把细节交给实现类去完成。

