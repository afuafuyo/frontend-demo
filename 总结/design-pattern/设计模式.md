## 设计模式的重要性

软件工程中，设计模式是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案。这个术语是由埃里希-伽马（ Erich Gamma ）等人在 20 世纪 90 年代从建筑设计领域引入到计算机科学的。

设计模式是用来解决特定问题的一系列套路，可以用来提高代码的复用性、扩展性和可靠性。

想象一下：

* 一个项目开发完成，客户提出了新功能（扩展性）
* 一个项目开发完成，原开发人员离职，怎么接手维护这个项目（可维护性、规范性）

哪里会用到设计模式

* 功能模块编写（算法数据结构 + 设计模式）
* 框架（设计模式）



## 设计模式七大原则

#### 设计模式目的

在实际工作中，程序员面临着来自耦合性、内聚性、可扩展性、重用性、灵活性等多方面的挑战。设计模式就是为了解决这些问题。

1. 复用性提高

    相同功能的代码不需要编写多次

2. 规范性提高

    规范的代码可读性更高，便于其他人阅读和理解

3. 可扩展性提高

    当需要增加新功能时非常方便，具有较高的可维护性

4. 可靠性提高

    新功能的变更不会导致旧功能出现异常

5. 程序对外呈现高内聚、低耦合

#### 设计模式为什么那样设计

设计模式也是有其设计依据的，主要有七大原则

1. 单一职责原则
2. 接口隔离原则
3. 依赖倒转原则
4. 里氏替换原则
5. 开闭原则
6. 迪米特原则
7. 合成复用原则

#### 1. 单一职责原则

【定义】单一职责原则又称单一功能原则，由 Robert C. Martin 于《敏捷软件开发：原则、模式和实践》一书中提出。职责指类发生变化的原因，单一职责原则规定一个类应该只有一个发生变化的原因。

如果一个类有多个被改变的原因，那这个类就具有多个职责。

如果一个类 A 负责两个职责：职责 1 和职责 2 ，那么当职责 1 需求变更而需要改变 A 类时，就可能造成对职责 2 的影响。单一职责原则中应该将不同职责分到不同的类实现。

【例】实现一个提示弹框

```react
class Dialog extends React.Component {
	show(msg: string) {
        return (
        	<div>
                <div>{msg}</div>
				<footer>
                    <button>确定</button>
                </footer>
            </div>
        );
    }
}

// 使用
class Page extends React.Component {
    // 想提示一条信息
    ReactDom.render(<Dialog msg="提交成功" />, document.body);

	// 想给用户选择
	ReactDom.render(<Dialog msg="您确定删除该条数据吗？" />, document.body);
}
```

以上 `Dialog` 类在此时场景下违反了单一职责原则，一般情况下人们会这样修改代码

```react
// 另一种违反单一职责原则的情况
class Dialog extends React.Component {
    // 修改了业务逻辑
	show(msg: string) {
        const showCancel = this.props.showCancel;

        return (
        	<div>
                <div>{msg}</div>
				<footer>
                    {showCancel ? <button>取消</button> : null}
                    <button>确定</button>
                </footer>
            </div>
        );
    }
}

// 使用
class Page extends React.Component {
    // 想提示一条信息
    ReactDom.render(<Dialog msg="您确定删除该条数据吗" showCancel={true} />, document.body);
}
```



根据单一职责原则进行代码修改

```react
// 采用类级别的分离
class Alert extends React.Component {
	show(msg: string) {
        return (
        	<div>
                <div>{msg}</div>
				<footer>
                    <button>确定</button>
                </footer>
            </div>
        );
    }
}

class Confirm extends React.Component {
	show(msg: string) {
        return (
        	<div>
                <div>{msg}</div>
				<footer>
                    <button>取消</button>
                    <button>确定</button>
                </footer>
            </div>
        );
    }
}

// 使用
class Page extends React.Component {
    // 想提示一条信息
    ReactDom.render(<Alert msg="提交成功" />, document.body);

	// 想给用户选择
	ReactDom.render(<Confirm msg="您确定删除该条数据吗？" />, document.body);
}
```

以上方案遵循了单一职责原则，但是改动比较大，我们还有优化的空间

```react
// 方法级别的单一职责原则
class Dialog extends React.Component {
	confirm(msg: string) {
        return (
        	<div>
                <div>{msg}</div>
				<footer>
                    <button>取消</button>
                    <button>确定</button>
                </footer>
            </div>
        );
    }

    alert(msg: string) {
        return (
        	<div>
                <div>{msg}</div>
				<footer>
                    <button>确定</button>
                </footer>
            </div>
        );
    }
}
```

综上，单一职责原则就是要做到各司其职，需要注意的事项和细节

1. 降低类的复杂度，一个类负责一个职责
2. 提高类的规范性和可扩展性
3. 降低需求变更引起的风险
4. 通常情况下，应遵循单一职责原则，只有在逻辑足够简单，类方法足够少的情况下，可以在方法级别保持单一职责原则



#### 2. 接口隔离原则

【定义】客户端不应该被迫依赖于它所不需要的方法；一个类对另一个类的依赖应该建立在最小的接口上。

单一职责原则和接口隔离原则都是为了提高类的内聚性，降低类之间的耦合性。

【例】实现一个内容处理器

```typescript
interface IContentProcessor {
    /**
     * 解析 html
     */
    parseHtml(content: string): string;

    /**
     * 解析协议
     */
    parseProtocol(content: string): string;
}

// 解析帖子的类
class PostContentProcessor implements IContentProcessor {
    parseHtml(content: string): string {
        // todo 解析 html
    }

    parseProtocol(content: string): string {
        // 不会使用
    }
}

// 解析动态的类
class DynamicProcessor implements IContentProcessor {
    parseHtml(content: string): string {
        // 不会使用
    }

    parseProtocol(content: string): string {
        // todo 解析协议
    }
}
```

以上接口设计导致内容处理类多余的实现了本身并不需要的方法，违反了接口隔离原则，需要优化

```typescript
interface IPostProcessor {
    /**
     * 解析 html
     */
    parseHtml(content: string): string;
}
interface IDynamicProcessor {
    /**
     * 解析协议
     */
    parseProtocol(content: string): string;
}

class PostContentProcessor implements IPostProcessor {
    parseHtml(content: string): string {
        // todo 解析 html
    }
}
class DynamicProcessor implements IDynamicProcessor {
    parseProtocol(content: string): string {
        // todo 解析协议
    }
}
class YbProcessor implements IPostProcessor, IDynamicProcessor {
    parseHtml(content: string): string {
        // todo
    }

    parseProtocol(content: string): string {
        // todo
    }
}
```



#### 3. 依赖倒转原则

【定义】高层模块不应该依赖低层模块（被依赖方即服务提供方为低层），两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。

依赖倒转的核心思想是要面向接口编程，而不是面向实现编程。

在软件设计中，细节往往具有多变性，而抽象层则相对稳定，因此以抽象为基础搭建起来的架构要比以细节为基础搭建起来的架构要稳定得多。

【例】手机上有很多可以被打开的 App ，设计一个使用手机的场景

```typescript
class Phone {
    openTaobao(tb: Taobao): void {
        tb.open();
    }
    
    openQQ(qq: QQ): void {
        qq.open();
    }
}

class Taobao {
    open(): void {}
}
class QQ {
    open(): void {}
}

class Client {
    run() {
        const phone = new Phone();
        phone.openTaobao(new Taobao());
        phone.openQQ(new QQ());
    }
}
```

以上设计表示为

![](./dp/dip.png)



按照依赖倒转原则优化代码

将应用进行抽象，形成一个独立的接口层，接口层负责提供打开应用的定义，具体的应用基于这个接口进行实现

![](./dp/dip-youhua.png)

```typescript
interface App {
    open(): void;
}

class QQ implements App {
    open(): void {}
}
class Taobao implements App {
    open(): void {}
}

class Phone() {
    openApp(app: App) {
        // 所有 app 都实现了同一套接口 都具有 open 方法
        app.open();
    }
}

class Client {
    run() {
        const phone = new Phone();
        phone.openApp(new QQ());
        phone.openApp(new Taobao());
    }
}
```



#### 4. 里氏替换原则

【定义】里氏替换原则由麻省理工学院 Liskov 女士在”面向对象技术的高峰会议“上发表的一篇文章《数据抽象和层次》中提出，继承必须确保超类所拥有的的性质在子类中依然成立

里氏替换原则主要阐述了关于继承的一些原则，即什么时候应该使用继承，什么时候不应该使用，以及其中蕴含的道理。

1. 父类已经实现的方法，相当于一些规范和契约，虽然子类可以不遵守这些契约（如将某方法进行重写），但子类对这些已实现的方法进行任意修改，会对集成体系造成破坏
2. 继承在给程序设计带来便利的同时，也带来了弊端。继承会给程序带来侵入性，使得程序可以执行降低，对象间耦合性增加。如果一个类 A 被其他类继承，那么后期对 A 类的修改，就需要考虑到所有的子类，子类可能会发生故障（耦合性故障）

如何正确使用继承？就是用到了里氏替换原则

里氏替换原则告诉我们，在子类中 `尽量不要重写父类的方法` ，在适当情况下可以使用 `聚合、组合或者依赖`来解决问题

```typescript
class A {
    // 求和
    fun(a: number, b: number): number {
        return a + b;
    }
}

class B extends A {
    // 无意中改为了求差
    fun(a: number, b: number): number {
        return a - b;
    }
    
    // 想求和 但是忘记重写了求和方法
    fun2(a: number, b: number， c: number): number {
        return this.fun(a, b) + c;
    }
}
```



使用依赖关系修改代码

```typescript
class B {
    constructor() {
        this.a = new A();
    }
    
    sub(a: number, b: number): number {
        return a - b;
    }
    
    plus(a: number, b: number, c: number): number {
        return this.a.fun(a, b) + c;
    }
}
```



#### 5. 合成复用原则

【定义】合成复用原则又叫组合/聚合复用原则，它要求在软件复用时，尽量先使用 `组合或者聚合` 等方式实现，其次才考虑使用继承，使用继承时还需考虑里氏替换原则

【例如】用户卡片展示用户信息的功能

![](./dp/dip-fuyong.png)



#### 6. 迪米特原则

【定义】迪米特原则又叫最少知识原则，由 Lan Holland 提出。迪米特原则定义是：只与你的直接朋友交谈。不要跟“陌生人”说话，其含义是，如果两个软件实体无需直接通信，那么就不应该发生直接的相互调用，可以通过第三方转发该调用，其目的是降低类之间的耦合度，提高模块间的独立性

朋友定义：当前对象的成员变量、当前对象创建的对象、当前对象的方法参数

陌生人：以局部变量方式出现的依赖对象

【例】某人想开发一款软件，需要找软件外包公司，而不是直接找软件开发人员



#### 7. 开闭原则

【定义】开闭原则是编程中 `最基础最重要` 的原则，由 Bertrand Meyer 在《面向对象软件构造》中提出：软件实体应当对扩展开放（服务提供方），对修改关闭（服务使用方）

当软件需求需求变化时，尽量通过扩展软件实体的行为来实现需求，而不是修改已有的代码

编程中遵循的其他原则，以及使用设计模式的目的核心是开闭原则

【例】实现一个画图类

```typescript
// 使用方
class DrawEditor {
    rectangle: Rectangle;
    circle: Circle;
    
    // 画矩形
    drawRectangle(): void {
        this.rectangle.draw();
    }
    
    // 画圆
    drawCircle(): void {
        this.circle.draw();
    }
}

// 提供方
class Rectangle {
    draw(): string {
        return '画出一个矩形';
    }
}
class Circle {
    draw(): string {
        return '画出一个圆';
    }
}
```

以上代码，如果需要扩展画图工具的功能，比如增加画三角形，就需要修改使用方代码，不符合开闭原则

按照开闭原则修改代码如下

```typescript
// 提供方
abstract class Shape {
    abstract draw(): string;
}
class Rectangle extends Shape {
    draw(): string {
        return '画出一个矩形';
    }
}
class Circle extends Shape {
    draw(): string {
        return '画出一个圆';
    }
}
class Triangle extends Shape {
    draw(): string {
        return '画出一个三角';
    }
}

// 使用方
class DrawEditor {
    drawShape(shape: Shape): void {
        shape.draw();
    }
}
```







