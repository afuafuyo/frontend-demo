## jmp 指令
    jmp 是无条件跳转指令
    格式
        jmp 标号
    注意
        jmp 指令虽然用标号指出了目的地址
        但是在 jmp 对应的机器码中却不包含目的地址
        实际上 jmp 的机器码中给出的是一个位移值
        计算过程为
            要跳转到的地址 = jmp 指令后的一条指令地址 + 偏移地址
                为什么是后一条指令地址
                    因为 cpu 读取 jmp 指令后 IP 会自增到下一条指令
                偏移地址
                    偏移地址可能为负数 为负数就是下一条指令地址 - 偏移值的绝对值

## ret 指令
    跳转指令
    cpu 实际是执行了 IP 出栈的操作

## call 指令
    跳转指令
    cpu 执行过程
        1. 将当前 IP 入栈（或者将 CS 和 IP 入栈）
        2. 跳转到标号

## mul 指令
    mul 是乘法指令
        被乘数 * 乘数 = 积
    格式
        mul 乘数寄存器

    乘数和被乘数都是 8 位
        此时被乘数默认在 AL 中 结果默认放在 AX 中
    乘数和被乘数都为 16 位
        此时被乘数默认在 AX 中 结果高位放在 DX 中 低位在 AX 中
    如果一个 8 位 一个 16 位
        需要手动将 8 位数据构造成 16 位再运算

## div 指令
    div 是除法指令
        被除数 / 除数 = 商 和 余数
    格式
        div 除数寄存器

    如果除数为 8 位
        此时被除数为 16 位并默认放在 ax 寄存器中
        商放到 AL 中 余数放到 AH 中
        反过来推导也行
            如果被除数用 16 位放不下 那么就需要用 32 位来存储
            此时除数就不得不手动构造成 16 位 这样电脑才能把被除数解释成 32 位

    如果除数为 16 位
        此时被除数为 32 位并默认存放在 DX 和 AX 中 （ DX 为高位 AX 为低位 ）
        商放到 AX 中 余数放到 DX 中
