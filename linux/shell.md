<pre>
/**
 * 环境变量配置文件
 */
source 命令
    source 配置文件
        强制让配置文件生效

环境变量配置文件中主要定义对系统的操作环境生效的系统默认环境变量
    PATH  -- 定义系统查找命令的路径

默认环境变量配置文件
    1. /etc/profile
        定义 USER 变量
        定义 LONGNAMW 变量
        定义 MAIL 变量
        定义 PATH 变量
        定义 HOSTNAME 变量
        定义 HISTSIZE 变量
        定义 umask 值
        调用 /etc/profile.d/*.sh

    2. /etc/profile.d/*.sh
        存放自定义环境配置

    3. ~/.bash_profile
        调用 ~/.bashrc
        追加 $HOME/bin 到 PATH 变量
        
    4. ~/.bashrc
        定义别名
        
    5. /etc/bashrc
        非正常登录配置

/**
 * 环境变量配置文件作用
 */
正常登录到命令行配置文件调用过程
    实线为主流程 虚线为中间调用流程

    /etc/profile  ————>  ~/.bash_profile  ————>  bash 界面
        |                       |
        |                       |-->  ~/.bashrc
        |                                  |
        |                                  |-->  /etc/bashrc
        |-->  /etc/profile.d/*.sh                    

/**
 * 其他配置文件
 */
注销时生效的环境变量配置文件
    ~/.bash_logout
历史命令配置文件
    ~/.bash_history
终端欢迎信息
    /etc/issue  -- 本地登录信息
    /etc/issue.net  -- 远程登录信息
    /etc/motd  -- 登录后信息

    /etc/ssh/sshd_config 中的 Banner 决定远程登录是否显示信息

/**
 * 文件安全与权限
 */
1. 文件
    当创建一个文件的时候 系统保存了文件的全部信息
        文件的位置
        文件的类型
        文件的权限
        i 节点
        文件的所有者 所有者所在的组
        文件的长度 ( 字节 )
        文件的修改日期
    
    ls -l 结果分析
        -rwxr-xr-x  1  root  root  56  5月  30  19:37  start.sh
            -rwxr-xr-x 文件的权限位
                - 文件的类型
                rwx 文件属主权限
                r-x 同组用户权限
                r-x 其他用户权限
            1 文件硬链接数目
            root 文件属主
            root 文件属主所在的缺省组 ( 主组 )
                /etc/passwd 中定义一个用户缺省组
                /etc/group 中定义用户所在的其他组
            56 文件的长度    
            5月30 19:37 文件的修改时间
            start.sh 文件名
    
2. 文件类型
    d 目录
    l 符号链接
    s 套接字文件
    b 块设备文件
    c 字符设备文件
    p 命名管道文件
    - 普通文件
    
3. 权限
    在 UNIX 的实现中 文件权限用 12 个二进制位表示 如果该位置上的值是 1 表示有相应的权限
    ---------------------------------------------------
    | 11 | 10 | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 | 位
    ---------------------------------------------------
    | S  | G  | T | r | w | x | r | w | x | r | w | x | 权限
    ---------------------------------------------------
    |             |    user   |   group   |   other   | 所有者 同组用户 其他人权限
    ---------------------------------------------------
    第 11 位为 SUID 位 第 10 位为 SGID 位 第 9 位为 sticky 位 第 8-0 位分为三组为 所有者 同组用户 其他人权限 
    
    rwxr-xr-x 表示为 111101101 及 755
        所有者 读写执行权限
        同组用户 读与执行权限
        其他人 读与执行权限
    
4. 改变权限
    符号模式
        chmod who operator permission filename
            who 含义
                u 文件属主
                g 同组用户
                o 其他用户
                a 所有用户
            operator 含义
                + 增加权限
                - 取消权限
                = 设置权限
            permission 含义
                r 读
                w 写
                x 执行
    
    绝对模式
        chmod [mode] file
            mode 八进制权限
                4 读
                2 写
                1 执行
        计算
            rwx r-x r-x
            7   5   5
    
5. 目录
    目录权限
        r 可以列出目录中的文件
        w 可以在目录中创建删除文件
        x 可以进入目录
    
    如果一个脚本文件所在目录权限为 --x 那么用户无法列出该文件 但是可以执行该文件

6. suid/guid (sgid)
    suid 意味着如果某个用户对属于自己的 shell 脚本设置了某种权限 那么其他用户在执行这一脚本时也会具有其属主的相应权限
    guid 执行相应脚本的用户将具有该文件所属用户组中用户的权限

    在 Unix 进程中涉及多个用户 ID 和用户组 ID
        1). 实际用户 ID 和实际用户组 ID 
            标识我是谁 也就是登录用户的 uid 和 gid
            比如 Linux 以 simon 登录 在 Linux 运行的所有的命令的实际用户 ID 都是 simon 的uid 实际用户组 ID 都是 simon 的 gid ( 可以用 id 命令查看 )
            
        2). 有效用户 ID 和有效用户组 ID
            进程用来决定我们对资源的访问权限
            一般情况下 有效用户 ID 等于实际用户ID 有效用户组 ID 等于实际用户组ID
            然而当有设置 SUID 位时 则有效用户 ID 等于文件的所有者的 uid 而不是实际用户ID
            如果设置了 SGID 位 则有效用户组 ID 等于文件所有者的 gid 而不是实际用户组ID
    
7. umask
    在 /etc/profile 中设置
    当最初登录到系统中时 umask 命令确定了你创建文件的缺省模式

    命令格式 umask nnn
        nnn 为 000-777
    
    对于文件来说 这一数字的最大值分别是 6 系统不允许你在创建一个文本文件时就赋予它执行权限 必须在创建后用 chmod 命令增加这一权限
    对于目录可以有执行权限 umask 中各个数字最大可以到 7

    一些 umask 值
    ---------------------------------
    |   umask   |   dir   |   file  |
    ---------------------------------
    |   022     |   755   |   644   |
    ---------------------------------
    |   027     |   750   |   640   |
    ---------------------------------
    |   002     |   775   |   664   |
    ---------------------------------
    |   007     |   770   |   660   |
    ---------------------------------

/**
 * find 使用
 */
find [path ...] [expression]
    默认路径为当前目录 默认表达式为 -print
        
    常用表达式
        -print find 命令将匹配的文件输出到标准输出
        -exec find 命令将匹配的文件执行该参数指定的 shell 命令
            命令格式为 command {} \;
            
            例如查找 index.js 并列出其内容
            find ./index.js -exec cat {} \;
        -ok 和 -exec 一样 只不过每次执行 command 之前会显示提示信息
        -name 按照文件名搜索
            find ~ -name '*.txt' -print

    -print 与 -print0
        -print 在每一个输出后会添加一个回车换行符 而 -print0 则不会
        
        例如在当前目录查找文件并输出 末尾不换行
            find index.js -print0

/**
 * xargs
 */
将参数列表转换成小块分段传递给其他命令 以避免参数列表过长的问题
可以取一个命令的输出作为另一个命令的参数

查找 .log 文件并删除
    find ./ -name '*.log' | xargs rm -f

/**
 * 后台执行命令
 */
1. & 命令
    格式
        command &
    
    当在前台运行某个作业时 终端被该作业占据 而在后台运行作业时 它不会占据终端 可以使用 & 命令把作业放到后台执行
    注意 作业在后台运行一样会将结果输出到屏幕上
    
2. ps 查看进程
    格式
         kill [-s sigspec | -n signum | -sigspec] pid
    
    ps 命令列出当前系统进程的快照
    注意 是执行 ps 命令时的进程快照
    
3. nohup 命令
    格式
        nohup command &
    
    该命令在你退出帐户之后继续运行相应的进程
    使用 nohup 命令提交的作业在缺省情况下该作业的所有输出都被重定向到一个名为 nohup.out 的文件中

/**
 * 文件名置换
 */
1. 使用 *
    星号 * 可以匹配文件名中的任何字符串
    
    列出当前目录下的 js 文件
        ls ./*.js

2. 使用 ?
    可以匹配文件名中的任何单个字符
    
3. 使用 []
    可以用来匹配方括号 [ ] 中的任意一个字符
    如果方括号中的第一个字符为 ! 表示不匹配这些字符

/**
 * 输出与输出
 */
1. echo
    echo 命令可以显示文本行或变量 或者把字符串输入到文件

2. read
    read 语句从键盘或文件的某一行文本中读入信息 并将其赋给一个或多个变量 如果只指定了一个变量 那么 read 将会把所有的输入赋给该变量 直至遇到第一个文件结束符或回车

3. cat
    cat 可以用来显示文件内容 创建文件 还可以用它来显示控制字符

4. 管道
    可以通过管道把一个命令的输出传递给另一个命令作为输入

    在文件列表搜索某文件
        ls | grep index.js
    
5. tee
    tee 把输出的一个副本输送到标准输出 另一个副本拷贝到相应的文件中

6. 标准输入 输出和错误
    在 shell 中执行命令的时候 每个进程都和三个打开的文件相联系 并使用文件描述符来引用这些文件
    
    文件描述符   |   文件
    -----------------------------------------
    0            |   输入文件 - 标准输入
    -----------------------------------------
    1            |   输出文件 - 标准输出
    -----------------------------------------
    2            |   错误输出文件 - 标准错误
    -----------------------------------------

7. 文件重定向
    在执行命令时 可以指定命令的标准输入 输出和错误 要实现这一点就需要使用文件重定向

    标准输出重定向
        > 或 1>
        >> 或 1>>
        command > filename
    标准输入重定向
        < 或 0<
        << 或 0<< 从标准输入中读入 直至遇到 delimiter 分界符
    标注错误重定向
        2>
        2>>
 
    把标准输出和标准错误一起重定向到一个文件中
        command > filename 2>&1

8. exec

/**
 * 命令执行顺序
 */
1. 使用 &&
    格式
        command1 && command2
    
    command1 执行成功才执行 command2

2. 使用 ||
    格式
        command1 || command2
    
    command1 执行失败才执行 command2

/**
 * grep 家族
 */
1. grep
    格式
        grep [options] pattern [file]
            -i 忽略大小写
            -n 输出行号
            -c 只输出匹配行的计数
        
    grep 允许对文本文件进行模式查找并输出匹配的行
       
2. 引号
    在调用变量匹配时 要用双引号 否则没有结果
        grep "$key" filename

3. 精确匹配
    使用 grep 精确匹配的一种更有效方式是在抽取字符串后加 \>
    
    精确搜索 demo 字符串
        grep 'demo\>' index.js
    
4. grep 和正则表达式
    可以在 grep 中使用正则表达式 使用正则表达式时最好用单引号括起来 这样可以防止 grep 中使用的专有模式与一些 shell 命令的特殊方式相混淆

5. 类名
    grep 允许使用国际字符模式匹配或匹配模式的类名形式
    
    类名及其等价的正则表达式
    -----------------------------------
    class        |   regular expression
    -----------------------------------
    [[:upper:]]  |   [A-Z]
    -----------------------------------
    [[:lower:]]  |   [a-z]
    -----------------------------------
    [[:digit:]]  |   [0-9]
    -----------------------------------
    [[:alnum:]]  |   [0-9A-Za-z]
    -----------------------------------
    [[:space:]]  |   空格或 tab
    -----------------------------------
    [[:alpha:]]  |   [A-Za-z]
    -----------------------------------

/**
 * 截取列命令 - cut
 */
cut [选项] 文件名
    -f  -- 指定要提取的列
    -d  -- 指定列分隔符 默认分隔符是 制表符

    截取文件的第 2 列
        cut -f 2 student.txt
	
/**
 * 截取列命令 - awk
 */
awk '条件1{动作1}条件2{动作2}' 文件名
    条件成立时才执行动作
    不写条件就是没有限制条件 始终执行动作
    awk 一次读取一行数据 并把每列赋值给 $1 - $n  $0 表示一行数据
	
    内置条件
        BEGIN 条件
            awk 'BEGIN{动作}'
                在其他动作之前首先执行 BEGIN 条件的动作
        END 条件
            在其他动作之后执行 END 条件的动作

    FS 动作指定列分隔符
        BEGIN{FS=":"}
            指定分隔符为冒号

    关系运算符
        echo '2 1' | awk '$1 > $2{printf "yes\n"}'
    
/**
 * 流编辑器 - sed
 */
sed [选项] '[动作]' 文件名
    选项
        -n  -- sed 会把所有数据都输出到屏幕 此选项会只把经过 sed 处理的行输出到屏幕
        -e  -- 允许对输入数据应用多条 sed 命令 多个 sed 用 ; 分隔
        -i  -- sed 的修改结果影响文件的数据

    动作
        xa  -- x 行后追加一行或多行
        xc  -- 把 x 行的数据替换成 c 后的数据
        xi  -- 在 x 行前插入一行或多行
        x,yd  -- 删除 x 到 y 行
        xp  -- 输出第 x 行
        s  -- 字符串替换 格式 '[行号]s/旧数据/新数据/g'

    打印文件第二行
        sed -n '2p' student.txt
    第二行后追加一行 hello
        sed '2a hello' student.txt
    在第二行前插入一行 hello
        sed '2i hello' student.txt
    替换第二行内容为 hello
        sed '2c hello' student.txt

/**
 * 排序命令
 */
sort [选项] 文件名
    -f  -- 忽略大小写
    -n  -- 以数值型进行排序
    -r  -- 反向排序
    -t  -- 制定分隔符 默认是 制表符 通常和 -k 一同使用
    -k n[,m]  -- 按照指定字段范围排序
	
/**
 * 统计命令
 */
wc [选项] 文件名
    -l  -- 只统计行数
    -w  -- 只统计单词数
    -m  -- 只统计字符数


/**
 * 条件判断
 */
两种方式
    1. test condition
        test -f /home/student.txt
    2. [ condition ]
        [ -f /home/student.txt ]
        使用方括号时 要注意在条件两边加上空格

文件类型判断
    -b 文件  -- 是否是块设备文件
    -c 文件  -- 死否是字符设备文件

    -d 文件  -- 是否是目录
    -e 文件  -- 文件是否存在
    -f 文件  -- 是否是普通文件
    -L 文件  -- 是否是符号链接文件

    -p 文件  -- 是否是管道文件
    -s 文件  -- 是否为空
    -S 文件  -- 是否为套接字文件

文件权限判断
    -r 文件  -- 文件是否可读
    -w 文件  -- 文件是否可写
    -x 文件  -- 文件是否可执行
	
数值比较
    n1 -eq n2  -- 是否相等
    n1 -ne n2  -- 是否不相等
    n1 -gt n2  -- n1 是否大于 n2
    n1 -lt n2  -- n1 是否小于 n2
    n1 -ge n2  -- n1 是否大于等于 n2
    n1 -le n2  -- n1 是否小于等于 n2

字符串判断
    -z 字符串  -- 字符串是否为空 返回 true or false
    -n 字符串  -- 是否非空
    s1 == s2  -- 是否相等
    s1 != s2  -- 是否不相等

多重判断
    condition1 -a condition2  -- 并且
    condition1 -o condition2  -- 或者
        
    判断 a.txt 和 b.txt 是否都是文件
        [ -f a.txt -a -f b.txt ]

/**
 * 数值运算
 */
shell 默认将变量赋值当做字符
要让 shell 识别数值要用 $ 和 []
[] 包含的数学算式可以被 shell 正确识别

如
    myvar=$[ $a+$b ]

/**
 * 流程控制 if else
 */
格式
    if condition ; then
        程序
    elif condition ; then
        程序
    else
        程序
    fi

/**
 * 流程控制 case
 */
格式
    case $变量 in
        'value1')
            变量值等于 value1 则执行此处
            ;;
        'value2')
            变量值等于 value2 则执行此处
            ;;
        *)
            变量值与上面都不相等 执行此处
            ;;
    esac

/**
 * 流程控制 for
 */
第一种格式
    for 变量 in value1 value2 ...
    do
        程序
    done

第二种格式
    for ((初始值; 控制条件; 变量变化))
    do
        程序
    done

/**
 * 流程控制 while until
 */
while 格式
    while condition
    do
        程序
    done

until 格式
    until condition
    do
        程序
    done
    
</pre>